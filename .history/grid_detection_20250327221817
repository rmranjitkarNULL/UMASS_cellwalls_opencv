import cv2
import numpy as np

def detect_grid_walls(image_path):
    # Read the image
    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    
    # Ensure the image is loaded
    if img is None:
        print(f"Error: Could not read image {image_path}")
        return None
    
    # Enhanced preprocessing
    # Apply contrast enhancement
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
    img = clahe.apply(img)
    
    # Noise reduction with bilateral filtering
    img = cv2.bilateralFilter(img, 9, 75, 75)
    
    # More aggressive blur and thresholding
    blurred = cv2.GaussianBlur(img, (9, 9), 0)
    
    # Adaptive thresholding with inverted binary
    thresh = cv2.adaptiveThreshold(
        blurred,
        255,
        cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv2.THRESH_BINARY_INV,
        15,  # Increased block size
        3   # Adjusted constant
    )
    
    # Morphological operations to close gaps
    kernel = np.ones((3,3), np.uint8)
    closed = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel, iterations=3)
    
    # Edge detection with adjusted Canny parameters
    edges = cv2.Canny(
        closed,
        threshold1=20,   # Lower threshold
        threshold2=120,  
        apertureSize=5   
    )
    
    # More aggressive dilation to connect line segments
    kernel_dilate = np.ones((5,5), np.uint8)
    dilated = cv2.dilate(edges, kernel_dilate, iterations=2)
    
    # More precise Hough Line Transform
    lines = cv2.HoughLinesP(
        dilated,
        rho=1,           # Distance resolution
        theta=np.pi/180, # Angle resolution
        threshold=50,    # Increased threshold
        minLineLength=50,# Longer minimum line length
        maxLineGap=10    # Increased max gap between segments
    )
    
    # Create a color image to draw lines on
    color_img = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
    
    # Draw the detected lines
    if lines is not None:
        for line in lines:
            x1, y1, x2, y2 = line[0]
            cv2.line(color_img, (x1, y1), (x2, y2), (0, 255, 0), 2)
    
    return color_img, edges, dilated

def process_and_show_steps(image_path):
    # Perform detection
    color_result, edges, dilated = detect_grid_walls(image_path)
    
    # Create a window to display multiple images
    combined = np.hstack([
        color_result  # Lines detected
    ])
    
    # Resize for better viewing
    scale_factor = 0.5
    resized = cv2.resize(combined, None, fx=scale_factor, fy=scale_factor)
    
    return resized

# Example usage (commented out as we can't actually run it)
image_paths = ['social.png']
for path in image_paths:
    result = process_and_show_steps(path)
    cv2.imshow(f'Grid Detection Steps - {path}', result)
    cv2.waitKey(0)
    cv2.destroyAllWindows()